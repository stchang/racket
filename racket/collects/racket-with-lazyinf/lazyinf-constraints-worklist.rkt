#lang racket
(require redex/reduction-semantics)


;; this is the version in plt-lazyinf/collects/racket-with-lazyinf/
;; differs from NEU_Research/lazyinf version in the following ways:
;; 1) possible-var-arrows hash, maps l ∈ ∆ to the var it reaches in some lazy pos
;; 2) var-arrows list of vars, contains those x vals in possible-var-arrows whose key l
;; actually gets delays in ins-del
;; 3) not-unrenamed is saved: equal to result of φ transformation,
;;    but still with unique vars

;; φ metafunction:
;; 1) performs analysis 
;; 2) rewrites input program using analysis results
(provide φ L ρ labels-to-delay labels-to-not-delay labels-to-force C*
         PRINT-LABELED-PROGRAM get-arrow-vars get-not-unrenamed strip-label)

(define PRINT-LABELED-PROGRAM (make-parameter #f))
(define PRINT-ENV (make-parameter #f))
(define PRINT-CONSTRAINTS (make-parameter #f))

;; lazyinf-constraints-worklist.rkt:
;; Computes analysis result for a given program via the algorithm from the
;; Nielson book:
;; 1) compute constraints
;; 2) solve via graph/worklist algorithm

;; TODO:
;; (o) = task open, [x] = task done
;; 2012-05-18:
;; [x] in constraint generation, prim case, add result to outer label
;;     - DONE 2012-05-29
;; [x] check fvs in delay and lcons to populate labels-to-delay set
;;     - probably need to create a new type of constraint
;;     - DONE 2012-05-19
;; [x] handle false case in pair?
;;     - DONE 2012-05-18
;; [x] filter out (arg l)'s in result of app and let
;;     - DONE 2012-05-18
;; [x] do actual (simulated) forcing in force case/force sites
;;     - DONE 2012-05-20
;; [x] change impl to not go under delay until they are forced
;;     - because we might inadvertently record some strict positions
;;     - DONE 2012-05-20
;; 2012-05-20
;; [x] - just dump all constants, literals, and primitives entirely?
;;     Right now, analysis is not using them anyways -- it's just always going
;;     to both if branches -- and all the tests are passing
;;     - DONE 2012-05-29
;; [x] - Right now we are always going under fn bodies, even for unused fns.
;;     Should we optimize so unused fn bodies are not analyzed? (would use the
;;     technique in Nielson MiniProject 3.1 with the flag set.
;;     Argument to NOT optimize:
;;     - all test are already passing
;;     - what if someone is writing libs, where fns wont be used but wants the 
;;     benefits of our tool anyways?
;;     - NOT IMPLEMENTED -- decided to always analyze fn bodies
;; 2012-06-19
;; [x] delays force themselves -- fix unsoundness
;; 2012-07-01
;; [x] dont filter args in delay and lcons

(define-language L
  ;; ideally, I should separate concrete and common expressions, but it makes
  ;; slightly more annoying to define labeled expressions, so I just leave them
  ;; combined
  (e n b valh (λ (x ...) e) x (p e e) (e e ...) (zero? e) (if e e e) (lab l e)
     null (null? e) (pair? e) (first e) (rest e)
     ; conses are like paper now (but different from lazyinf-no-int.rkt)
     (cons e e)  ; eager cons
     (lcons e e) ; lazy in 2nd position (same as paper)
     (lazy e) (force e) (let ([x e] ...) e ) (not e))
  #;(v (λ (x ...) e) n b null (cons v v) (lcons v e) (lazy e))
  (lit n b null) ; literals
  (vh (λ (x ...) l) valh (arg l) (cons l l) (lcons l l) (lazy l) (darg l))
  (d (define (f x ...) e))
  (prog (d ... e))
  (n integer)
  (l natural) ; labels
  #;(nh pos neg 0)
  (b true false)
  (anycons cons lcons)
  (aop + - * /)
  (cmp < > =)
  (bop and or)
  (p aop cmp bop)
  ((f x) variable-not-otherwise-mentioned)
  ; constraints
  (c (vh ∈ key)
     ({vh ...} ⊆ key)
     (key ⊆ key)
     (vh ∈ key ⇒ vh ∈ key)
     (mf ? key ⇒ vh ∈ key) ; predicate on ρ(key), could remove this and use ∀
     (vh ∈ key ⇒ key ⊆ key)
     ; constraints generated by applying metafunction mf to saved arguments
     ; version for λ is ∀ x ∈ l_fn: (mf x l_fn l_arg ... l_outer)
     (∀ mf ∈ key : l ...)
     (l ∈ ∆) ; add to labels-to-delay
     (l ∈ θ) ; add to labels-to-not-delay
     (l ∈ Γ) ; add to labels-to-force
     ((l_1 l_2) ∈ Γ) ; add l_1 to labels-to-force because of delay at l_2
     )
  (mf any) ; metafunction that generates constraints
  (key l x) ; keys (ie, keys to the ρ hash rable) are labels or variables
  )

(define λ? (redex-match L (λ (x ...) any)))
(define cons? (redex-match L (cons any_1 any_2)))
(define lcons? (redex-match L (lcons any_1 any_2)))
;(define (any-cons? t) (or (cons? t) (lcons? t)))
(define anycons? (redex-match L (anycons any_1 any_2)))
(define arg? (redex-match L (arg l)))
(define darg? (redex-match L (darg l)))
(define (non-arg? t) (not (arg? t)))
(define delay? (redex-match L (lazy any)))

;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Language Utility Functions
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------

; subst-vars: variable substitution with capturing
; from example at redex.racket-lang.org/lam-v.html
(define-metafunction L
  subst-vars : (x any) ... any -> any
  [(subst-vars (x_1 any_1) x_1) any_1]
  [(subst-vars (x_1 any_1) (any_2 ...)) 
   ((subst-vars (x_1 any_1) any_2) ...)]
  [(subst-vars (x_1 any_1) any_2) any_2]
  [(subst-vars (x_1 any_1) (x_2 any_2) ... any_3) 
   (subst-vars (x_1 any_1) 
               (subst-vars (x_2 any_2) ... any_3))]
  [(subst-vars any) any])

;; fv : e -> (x ...)
;; extract free variables in e
(define (fv t)
  (define s (set))
  (define (s-add! x) (set! s (set-add s x)))
  (define (s-remove! x) (set! s (set-remove s x)))
  (define-metafunction L
    fv_ : e -> any ; void
    [(fv_ (lab l e)) (fv_ e)]
    [(fv_ nh) ,(void)]
    [(fv_ valh) ,(void)]
    [(fv_ n) ,(void)]
    [(fv_ b) ,(void)]
    [(fv_ x_1) ,(s-add! (term x_1))]
    [(fv_ (λ (x_1 ...) e)) ,(void)
     (side-condition (term (fv_ e)))
     (side-condition (for-each s-remove! (term (x_1 ...))))]
    [(fv_ (p e ...)) ((fv_ e) ...)]
    [(fv_ (e ...)) ((fv_ e) ...)]
    [(fv_ (zero? e)) (fv_ e)]
    [(fv_ (if e ...)) ((fv_ e) ...)]
    [(fv_ (cons e ...)) ((fv_ e) ...)]
    [(fv_ (lcons e ...)) ((fv_ e) ...)]
    [(fv_ null) ,(void)]
    [(fv_ (null? e)) (fv_ e)]
    [(fv_ (pair? e)) (fv_ e)]
    [(fv_ (first e)) (fv_ e)]
    [(fv_ (rest e)) (fv_ e)]
    [(fv_ (lazy e)) (fv_ e)]
    [(fv_ (force e)) (fv_ e)]
    [(fv_ (not e)) (fv_ e)]
    [(fv_ (arg l)) ,(void)]
    [(fv_ (darg l)) ,(void)]
    [(fv_ (let ([x e] ...) e_1)) ,(void)
     (side-condition (term (fv_ e_1)))
     (side-condition (for-each s-remove! (term (x ...))))
     (side-condition (term ((fv_ e) ...)))])
  (term (fv_ ,t))
  s)

;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Set Utility Functions
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------

;; set-filter : pred set -> set
(define (set-filter p? s)
  (for/set ([x (in-set s)] #:when (p? x)) x))

;; mutate set s to add x
(define-syntax-rule (set-add! s x) (set! s (set-add s x)))

;; mutate set s1 to add elements of set s2
(define-syntax-rule (set-union! s1 s2) (set! s1 (set-union s1 s2)))


;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Program Transforming Function
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------

(define (reset)
  (set! count 0)
  (set! bound-vars (term ()))
  (set! def-vars (term ()))
  (set! lab->n-table (make-hash))
  (set! possible-arrow-vars (make-hash))
  (set! arrow-vars null)
  (set! not-unrenamed null)
;  (set! constraints (set))
  (reset-run))
(define (reset-run)
;  (set! C (make-hash))
  (set! ρ (make-hash))
;  (reset-done?-set)
  (set! labels-to-force (set))
  (set! labels-to-delay (set))
  (set! labels-to-not-delay (set))
  )

; φ : prog -> prog
; transforms program into one with delay/force annotations as needed
(define-metafunction L
  φ : prog -> prog
  [(φ prog) prog_final
   (side-condition (reset))
   (where prog_labeled (ξ prog))
   (side-condition
    (when (PRINT-LABELED-PROGRAM)
      (printf "LABELED: ----------\n")
      (pretty-print (term prog_labeled))
      (printf "-------------------\n")))
   (where (c ...) (C* prog_labeled)) ; generate constraints
   (side-condition (when (PRINT-CONSTRAINTS)
                     (for-each (λ (x) (printf "~a\n" x)) (term (c ...)))))
   (side-condition (solve-constraints (term (c ...))))
;   (side-condition
;    (printf "labels-to-delay: ~a\n" labels-to-delay))
;   (side-condition
;    (printf "labels-to-not-delay: ~a\n" labels-to-not-delay))
;   (side-condition
;    (printf "delayed labels: ~a\n" (set-subtract labels-to-delay labels-to-not-delay)))
   (where prog_delayed (insert-delays prog_labeled))
   (where prog_forced (insert-forces prog_delayed))
   (side-condition (set! not-unrenamed (term prog_forced)))
   (where prog_final (unξ prog_forced))
   #;(side-condition
    (when true
      (printf "OUTPUT: -----------\n")
      (pretty-print (term prog_final))
      (printf "-------------------\n")))
   ])


;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Labeling and Variable Freshening Functions
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------


;; ----------------------------------------------------------------------------
;; Labeling:

;; count = next label
(define count 0)
(define (get-next-label)
  (begin0
    count
    (set! count (add1 count))))

;; lab->n-table : label -> n
;; when converting program to abstract program, save concrete ints in this table
;; so original program can be recovered
(define lab->n-table (make-hash))

;; label : e -> (lab l e)
;; labels a given expression with the next label
(define-metafunction L
  label : e -> (lab l e)
  [(label e) (lab ,(get-next-label) e)])

;; maps label to variable that is source of laziness
(define possible-arrow-vars (make-hash))
(define arrow-vars null)
(define (add-arrow-var! x)
  (set! arrow-vars (append arrow-vars (list x)))) ; want a fifo
(define (get-arrow-vars) arrow-vars)

(define not-unrenamed null)
(define (get-not-unrenamed) not-unrenamed)
(define (strip-label t)
  (define-metafunction L
    str : any -> any ; define or e -> define or e
    [(str (lab l e)) e]
    [(str any) any])
  (term (str ,t)))

;; ----------------------------------------------------------------------------
;; Freshening:

;; bound-vars : (x ...)
;; list of term variables
(define bound-vars (term ()))
;; add-bound-var : term -> void
(define (add-bound-var x) (set! bound-vars (cons x bound-vars)))
(define (add-bound-vars xs) (set! bound-vars (append xs bound-vars)))
;; bound-var? : term -> any or #f
(define (bound-var? x) (member x bound-vars))

;; def-vars : (x ...)
;; list of variables bound to top level fns (ie defined with "define")
(define def-vars (term ()))
(define (add-def-var x) (set! def-vars (cons x def-vars)))
(define (def-var? x) (member x def-vars))



;; ----------------------------------------------------------------------------
;; ξ metafunction:
;; - renames vars to be unique and labels all subexpressions
;; - converts concrete ints to abstract pos/neg/0 values
;;   but saves the concrete ints so original program can be recovered
(define-metafunction L
  ξ : prog -> prog
  [(ξ (d ... e)) 
   prog_1
   (where prog_1 ((ξd d) ... (ξe e)))])

;; ξd renames and labels definitions
(define-metafunction L 
  ξd : d -> d
  [(ξd (define (f x ...) e))
   (define (f x_new ...) (ξe (subst-vars (x x_new) ... e)))
   (side-condition (and (not (def-var? (term f)))
                        (add-def-var (term f))
                        (add-bound-var (term f))))
   (where (x_new ...) ,(variables-not-in bound-vars (term (x ...))))
   (side-condition (add-bound-vars (term (x_new ...))))]
  [(ξd (define (f x) e)) #f
   (side-condition (def-var? (term f)))
   (side-condition 
    (printf "error: redefinition of previously defined name: ~a\n" (term f)))
   (side-condition #f)])

;; ξe : renames and labels expressions
(define-metafunction L 
  ξe : e -> (lab l e)
  [(ξe (λ (x ...) e))
   (label (λ (x_new ...) (ξe (subst-vars (x x_new) ... e))))
   (where (x_new ...) ,(variables-not-in bound-vars (term (x ...))))
   (side-condition (add-bound-vars (term (x_new ...))))]
  [(ξe (let ([x_1 e_1] ...) e))
   (label (let ([x_new (ξe e_1)] ...) (ξe (subst-vars (x_1 x_new) ... e))))
   (where (x_new ...) ,(variables-not-in bound-vars (term (x_1 ...))))
   (side-condition (add-bound-vars (term (x_new ...))))]
  [(ξe (p e ...))     (label (p (ξe e) ...))]
  [(ξe (e ...))       (label ((ξe e) ...))]
  [(ξe (zero? e))     (label (zero? (ξe e)))]
  [(ξe (null? e))     (label (null? (ξe e)))]
  [(ξe (pair? e))     (label (pair? (ξe e)))]
  [(ξe (not e))       (label (not (ξe e)))]
  [(ξe (if e ...))    (label (if (ξe e) ...))]
  [(ξe (cons e ...))  (label (cons (ξe e) ...))]
  [(ξe (lcons e ...)) (label (lcons (ξe e) ...))]
  [(ξe (first e))       (label (first (ξe e)))]
  [(ξe (rest e))       (label (rest (ξe e)))]
  [(ξe (lazy e))      (label (lazy (ξe e)))]
  [(ξe (force e))     (label (force (ξe e)))]
  [(ξe lit)             (lab l valh)
   (where (lab l lit)   (label lit))
   (side-condition (hash-set! lab->n-table (term l) (term lit)))]
  [(ξe any)           (label any)]) ; handles vars

;; unξ : unlabels program
;; uses saved literals in lab->n-table
(define-metafunction L
  unξ : prog -> prog
  [(unξ ((define (f x ...) e_1) ... e))
   ((define (f x ...) (unξe e_1)) ... (unξe e))])
(define-metafunction L
  unξe : e -> e
  [(unξe (lab l valh)) (unξe lit)
   (where lit ,(hash-ref lab->n-table (term l) #f))
   #;(side-condition (term n))]
  [(unξe (lab l e)) (unξe e)]
  [(unξe n) n] [(unξe b) b] [(unξe null) null] [(unξe x) x]
  [(unξe (λ (x ...) e)) (λ (x ...) (unξe e))]
  [(unξe (e ...)) ((unξe e) ...)]
  [(unξe (let ([x_1 e_1] ...) e)) (let ([x_1 (unξe e_1)] ...) (unξe e))]
  [(unξe (p e ...)) (p (unξe e) ...)]
  [(unξe (zero? e)) (zero? (unξe e))]
  [(unξe (null? e)) (null? (unξe e))]
  [(unξe (pair? e)) (pair? (unξe e))]
  [(unξe (not e)) (not (unξe e))]
  [(unξe (if e ...)) (if (unξe e) ...)]
  [(unξe (cons e ...)) (cons (unξe e) ...)]
  [(unξe (lcons e ...)) (lcons (unξe e) ...)]
  [(unξe (first e)) (first (unξe e))]
  [(unξe (rest e)) (rest (unξe e))]
  [(unξe (lazy e)) (lazy (unξe e))]
  [(unξe (force e)) (force (unξe e))])

;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Constraint Generating
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------

(define-syntax-rule (append-constraints cs) (foldr append null cs))

;; [SetOf c] : set of constraints
;(define constraints (set))
;(define-syntax-rule (add-constraint c) (set-add! constraints (term c)))
;(define-syntax-rule (add-constraints cs)
;  (for-each (λ (c) (add-constraint ,c)) (term cs)))
;(define-syntax-rule (∧ c ...) (begin c ...))
(define-syntax-rule (forcing-constraint l) 
  (term ((∀ ,forcing-mf ∈ l :)
         (∀ ,add-not-delay-mf ∈ l :))))
  
;; C* metafunction populates global constraints set
(define-metafunction L
  C* : prog -> (c ...)
  [(C* (d ... e)) 
   ,(foldr append null (term ((C*d d) ... (C*e e))))])
;; ⊨ define f(x ...) = e iff(λ (x ...) e) ∈ ρ(f) ∧ ⊨ e
(define-metafunction L
  C*d : d -> (c ...)
  [(C*d (define (f x ...) (lab l_0 e_0)))
   (((λ (x ...) l_0) ∈ f) ,@(term (C*e (lab l_0 e_0))))])
;; C*e, as a Racket fn instead of a metafunction
(define (C*e-fn t) (term (C*e ,t)))
(define-metafunction L
  C*e : e -> (c ...)
  ;; literals: num, bool, null
  [(C*e (lab l valh))   ((valh ∈ l))]
  ;; num
;;  [(C*e (lab l nh))   ((nh ∈ l))]
  ;; bool
;;  [(C*e (lab l b))    ((b ∈ l))]
  ;; null
;;  [(C*e (lab l null)) ((null ∈ l))]
  ;; var
  [(C*e (lab l x))    ((x ⊆ l))]
  ;; lam
  [(C*e (lab l (λ (x ...) (lab l_0 e_0))))
   (((λ (x ...) l_0) ∈ l) 
    ,@(term (C*e (lab l_0 e_0))))]
  ;; delay
  [(C*e (lab l (lazy (lab l_0 e_0))))
   (((lazy l_0) ∈ l)
    ,@(term (C*e (lab l_0 e_0)))
    #;(∀ ,filter-arg-mf ∈ l_0 : l)
    (l_0 ⊆ l)
    ,@(set-map 
       (fv (term e_0))
       (λ (x) (term (∀ ,add-delay-mf ∈ ,x :)))))]
  ;; force
  [(C*e (lab l_outer (force (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    (∀ ,force-mf ∈ l_1 : l_outer)
    (∀ ,add-not-delay-mf ∈ l_1 :))]
  ;; app (not analyzing body because it's done at def site)
  [(C*e (lab l_outer ((lab l_fn e_fn) (lab l_arg e_arg) ...)))
   (,@(term (C*e (lab l_fn e_fn))) ; ⊨ efn^lfn 
    ,@(forcing-constraint l_fn)    ; forcing lfn
    ,@(append-constraints          ; ⊨ earg^larg ∧ ... 
       (map C*e-fn (term ((lab l_arg e_arg) ...))))
    (∀ ,λ-mf ∈ l_fn : l_arg ... l_outer))]
  ;; if
  [(C*e (lab l_outer (if (lab l_test e_test) (lab l_1 e_1) (lab l_2 e_2))))
   (,@(term (C*e (lab l_test e_test)))
    ,@(forcing-constraint l_test)
    ,@(term (C*e (lab l_1 e_1))) ,@(term (C*e (lab l_2 e_2)))
     (l_1 ⊆ l_outer)
     (l_2 ⊆ l_outer))]
  ;; let
  [(C*e (lab l_outer (let ([x_1 (lab l_1 e_1)] ...) (lab l_body e_body))))
   (,@(foldr append null
       (map C*e-fn (term ((lab l_1 e_1) ...))))
    ,@(term (C*e (lab l_body e_body)))
    (l_1 ⊆ x_1) ...
    ((arg l_1) ∈ x_1) ...
    (∀ ,filter-arg-mf ∈ l_body : l_outer))]
  ;; prim op
  [(C*e (lab l (p (lab l_1 e_1) (lab l_2 e_2))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(term (C*e (lab l_2 e_2)))
    (valh ∈ l)
    ,@(forcing-constraint l_1)
    ,@(forcing-constraint l_2))]
  ;; zero?
  [(C*e (lab l (zero? (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(forcing-constraint l_1)
;    (0 ∈ l_1 ⇒ true  ∈ l)
;    (pos ∈ l_1 ⇒ false ∈ l)
;    (neg ∈ l_1 ⇒ false ∈ l))
    (valh ∈ l))]
  ;; null?
  [(C*e (lab l (null? (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(forcing-constraint l_1)
;    (null ∈ l_1 ⇒ true ∈ l)
;    (,anycons? ? l_1 ⇒ false ∈ l))
    (valh ∈ l))]
  ;; pair?
  [(C*e (lab l (pair? (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(forcing-constraint l_1)
;    (,anycons? ? l_1 ⇒ true ∈ l)
;    (,(λ (x) (and (not (anycons? x)) (not (arg? x)))) ? l_1 ⇒ false ∈ l))
    (valh ∈ l))]
  ;; not
  [(C*e (lab l (not (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(forcing-constraint l_1)
;    (true ∈ l_1 ⇒ false ∈ l)
;    (false ∈ l_1 ⇒ true ∈ l))
    (valh ∈ l))]
  ;; cons
  [(C*e (lab l (cons (lab l_1 e_1) (lab l_2 e_2))))
   (,@(term (C*e (lab l_1 e_1))) ,@(term (C*e (lab l_2 e_2)))
   ((cons l_1 l_2) ∈ l))]
  ;; lcons
  [(C*e (lab l (lcons (lab l_1 e_1) (lab l_2 e_2))))
   (,@(term (C*e (lab l_1 e_1))) ,@(term (C*e (lab l_2 e_2)))
   ((lcons l_1 l_2 #;(lab l_2 e_2)) ∈ l)
   ,@(set-map 
      (fv (term e_2))
      (λ (x) (term (∀ ,add-delay-mf ∈ ,x :)))))]
  ;; first
  [(C*e (lab l_outer (first (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(forcing-constraint l_1)
    (∀ ,first-mf ∈ l_1 : l_outer))]
  ;; rest
  [(C*e (lab l_outer (rest (lab l_1 e_1))))
   (,@(term (C*e (lab l_1 e_1)))
    ,@(forcing-constraint l_1)
    (∀ ,rest-mf ∈ l_1 : l_outer))]
  ;; else error
  [(C*e e) () (side-condition (printf "ERROR! Unhandled case in C*e: ~a\n" (term e)))])

;; metafunctions (mf) for ∀ constraints
(define (λ-mf . args)
  (define-metafunction L
    λ-mf : l ... -> (c ...)
    [(λ-mf l_fn l_arg ... l_outer)
     ,(let ([λs (set-filter λ? (lookup-in-ρ (term l_fn)))]) ;∀λ ∈ ρ(l_fn)
        (append-constraints
         (set-map 
          λs
          (λ (t)
            (define-metafunction L
              get-λ-cs : (λ (x ...) l) -> (c ...)
              [(get-λ-cs (λ (x ...) l_body #;(lab l_body e)))
               ((l_arg ⊆ x) ... ((arg l_arg) ∈ x) ... 
                (∀ ,filter-arg-mf ∈ l_body : l_outer))])
            (term (get-λ-cs ,t))))))])
  (term (λ-mf ,@args)))

(define (first-mf . args)
  (define-metafunction L
    first-mf : l ... -> (c ...)
    [(first-mf l l_outer)
     ,(let ([conss (set-filter anycons? (lookup-in-ρ (term l)))]) ;∀Xcons ∈ ρ(l)
        (set-map 
         conss
         (λ (t)
           (define-metafunction L
             get-c : (anycons l any) -> c
             [(get-c (anycons l_1 any)) (l_1 ⊆ l_outer)])
           (term (get-c ,t)))))])
  (term (first-mf ,@args)))

(define (rest-mf . args)
  (define-metafunction L
    rest-mf : l ... -> (c ...)
    [(rest-mf l l_outer)
     ,(let ([conss (set-filter anycons? (lookup-in-ρ (term l)))]) ;∀Xcons ∈ ρ(l)
        (append-constraints
        (set-map 
         conss
         (λ (t)
           (define-metafunction L
             get-c : (anycons l any) -> (c ...)
             [(get-c (cons any l_1)) ((l_1 ⊆ l_outer))]
             [(get-c (lcons any l_1)) (((lazy l_1) ∈ l_outer)
                                       #;(∀ ,filter-arg-mf ∈ l_1 : l_outer)
                                       (l_1 ⊆ l_outer)
                                       )])
           (term (get-c ,t))))))])
  (term (rest-mf ,@args)))

(define (filter-arg-mf . args)
  (define-metafunction L
    filter-arg-mf : l ... -> (c ...)
    [(filter-arg-mf l l_outer)
     ,(let ([non-args (set-filter non-arg? (lookup-in-ρ (term l)))]) ;∀vh ∈ ρ(l)
        (set-map 
         non-args
         (λ (t)
           (define-metafunction L
             get-c : vh -> c
             [(get-c vh) (vh ∈ l_outer)])
           (term (get-c ,t)))))])
  (term (filter-arg-mf ,@args)))
; used by force
;; similar to forcing-mf except result of forcing is propogated to outer label
;; ∀(delay el0) ∈ ρ(l): ⊨ el0 ∧ ρ(l0) ⊆ ρ(l_outer)
;; ∀vh≠delay    ∈ ρ(l): vh ∈ ρ(l_outer)
(define (force-mf . args)
  (define-metafunction L
    force-mf : l l -> (c ...)
    [(force-mf l l_outer)
     ,(let ([vhs (lookup-in-ρ (term l))]) ;∀vh ∈ ρ(l)
        (append-constraints
        (set-map 
         vhs
         (λ (t)
           (define-metafunction L
             get-c : vh -> (c ...)
             [(get-c (lazy l_0 #;(lab l_0 e_0))) ; skip delays now
              (#;(∀ ,filter-arg-mf ∈ l_0 : l_outer) 
               #;,@(term (C*e (lab l_0 e_0))))]
             [(get-c vh) ((vh ∈ l_outer))]) ; vh ≠ delay
           (term (get-c ,t))))))])
  (term (force-mf ,@args)))
;; used by all strict positions via add-forcing-constraint
;; forcing l = 
;; ∀(delay el0) ∈ ρ(l): ⊨ el0 ∧ ρ(l0) ⊆ ρ(l)
;; ∃(delay e) ∈ ρ(l) ⇒ l      ∈ Γ
;; ∀(darg l1) ∈ ρ(l): (l,l1) ∈ Γ
(define (forcing-mf . args)
  (define-metafunction L
    forcing-mf : l -> (c ...)
    [(forcing-mf l)
     ,(let* ([vhs (lookup-in-ρ (term l))]
             [delays (set-filter delay? vhs)] ;∀delay ∈ ρ(l)
             [dargs (set-filter darg? vhs)])  ;∀darg  ∈ ρ(l)
        (append
         (if (set-empty? delays)
             (term ())
             (cons 
              (term (l ∈ Γ)) ; ∃(delay e) ∈ ρ(l) ⇒ l ∈ Γ
              null
              #;(append-constraints
              (set-map 
               delays
               (λ (t)
                 (define-metafunction L
                   get-c : (lazy l) -> (c ...)
                   [(get-c (lazy l_0 #;(lab l_0 e_0))) 
                    ((∀ ,filter-arg-mf ∈ l_0 : l)
                     #;,@(term (C*e (lab l_0 e_0))))])
                 (term (get-c ,t)))))))
         (set-map
          dargs
          (λ (t)
            (define-metafunction L
              get-c : (darg l) -> c
              [(get-c (darg l_1)) ((l l_1) ∈ Γ)])
            (term (get-c ,t))))))])
  (term (forcing-mf ,@args)))
;; for input x, adds constraint ∀(arg l) ∈ ρ(x): (l ∈ ∆) ∧ (darg l) ∈ ρ(x)
;; used by lazy and lcons forms
(define (add-delay-mf . args)
  (define-metafunction L
    add-delay-mf : x -> (c ...)
    [(add-delay-mf x)
     ,(let ([args ; ∀(arg l) ∈ ρ(x):
             (set-filter arg? (lookup-in-ρ (term x)))]) 
        (append-constraints
         (set-map 
          args
          (λ (t)
            (define-metafunction L
              get-cs : (arg l) -> (c ...)
              [(get-cs (arg l)) ((l ∈ ∆) ((darg l) ∈ x))
               (side-condition (hash-set! possible-arrow-vars (term l) (term x)))])
            (term (get-cs ,t))))))])
  (term (add-delay-mf ,@args)))
;; used in force form and forcing constraint to populate labels-to-not-delay
;; ∀(arg l1) ∈ ρ(l): l1 ∈ θ
(define (add-not-delay-mf . args)
  (define-metafunction L
    add-not-delay-mf : l -> (c ...)
    [(add-not-delay-mf l)
     ,(let ([args (set-filter arg? (lookup-in-ρ (term l)))]) ;∀arg ∈ ρ(l)
        (set-map 
         args
         (λ (t)
           (define-metafunction L
             get-c : (arg l) -> any ; void
             [(get-c (arg l_1)) (l_1 ∈ θ)])
           (term (get-c ,t)))))])
  (term (add-not-delay-mf ,@args)))


;; gets constraints from a ∀ constraint
;; applies the stored metafunction to the stored arguments
(define-metafunction L
  ∀c->cs : (∀ mf ∈ key : l ...) -> (c ...)
  [(∀c->cs (∀ mf ∈ key : l ... ))
   ,(apply (term mf) (term key) (term (l ...)))])


;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Constraint Solving
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------

;; C : (l |-> [SetOf (term vh)]) ...
;; map from labels to sets of (abstract) value terms
;; 2012-05-17: using ρ as C + ρ combined now, so dont need C
;(define C (make-hash))
;(define-syntax-rule (lookup-in-C key) (hash-ref C key (λ _ (set))))
  
;; ρ : (x or l |-> [SetOf (term vh)]) ...
;; map from variable terms to sets of (abstract) value terms
(define ρ (make-hash))
(define-syntax-rule (lookup-in-ρ key) (hash-ref ρ key (λ _ (set))))

;; \hat{∆} in paper
(define labels-to-delay (set))
(define-syntax-rule (add-to-labels-to-delay l)
  (set-add! labels-to-delay l))
;; \hat{θ} in paper
(define labels-to-not-delay (set))
(define-syntax-rule (add-to-labels-to-not-delay l)
  (set-add! labels-to-not-delay l))
; [SetOf (term l)]
; \hat{Γ} in paper
(define labels-to-force (set))
(define-syntax-rule (add-to-labels-to-force l)
  (set-add! labels-to-force l))

  
  
;; populate C and ρ sets using constraints set
(define (solve-constraints constraints)

  ;; Step 1) Initialize Data Structures ---------------------------------------
  ;; list of "nodes" (ie, labels and vars)
  ;; If a node x is in the worklist it means, its associated values have been
  ;; updated, so the other nodes that depend on x must be updated as well
  (define worklist null)
  (define-syntax-rule (worklist-add! key) (set! worklist (cons key worklist)))

  ; rhs -> [SetOf vh] ; maps var or label to set of (abstract) values
;  (define D (make-hash)) ; no need for this, same as C + ρ combined

  ; E = "edges" (but not exactly, see description below in step 2)
  ; key -> [SetOf c] ; maps var or label to set of constraints
  (define E (make-hash))
  ;; looks up lhs in E; returns empty set if lhs is not in E
  (define-syntax-rule (lookup-in-E key) (hash-ref E key (λ _ (set))))
  (define-syntax (E-add! stx)
    (syntax-case stx (→)
      [(_ key → c)
       #'(let ([cs (lookup-in-E (term key))])
           (unless (set-member? cs (term c))
             (hash-set! E (term key) (set-add cs (term c)))))]))

  ;; add : 
  ;; Tries to add set of (abstract) values new-vhs to set associated with
  ;; node rhs. If some of the new-vhs are new (ie not already in D(rhs)), then
  ;; add rhs to the worklist so the nodes that depend on it can be updated as
  ;; well.
  (define (add key new-vhs)
    (define vhs (lookup-in-ρ key))
    (unless (subset? new-vhs vhs)
      (hash-set! ρ key (set-union vhs new-vhs))
      (worklist-add! key)))

  ;; Step 2) Build Graph ------------------------------------------------------
  ;; Summary:
  ;; - "Nodes" are labels and variables and each is associated with a set of 
  ;;   (abstract) values that flow to that position
  ;;   (this is the D hash table) (using C instead now)
  ;; - "Edges" represent dependencies between Nodes where ∃ node1 -> node2 if
  ;;   node1 affects node2
  ;;     ie if C(l_1) ⊆ C(l_2) then l_1 -> l_2 because 
  ;;        when C(l_1) changes, then C(l_2) must be updated
  ;; - Edges are not stored explicitly. Instead each node is associated with a
  ;;   a set of constraints, from which the neighboring nodes can be calculuated
  ;;   (Seems like this is done because the constraint has additional info that
  ;;    dictates HOW to update the dependent nodes. We would lose this extra
  ;;    information if we just stored edges as pairs of nodes.
  ;;    We need this extra information because "dependency" is more than just
  ;;    set membership. There are many different ways to "depend" on a node,
  ;;    like in the implication constraint.)
  ;; Racket fn version of add-c-to-graph
  (define (add-c-to-graph-fn c) (term (add-c-to-graph ,c)))
  ;; adds constraint to graph
  (define-metafunction L
    add-c-to-graph : c -> any ; void
    [(add-c-to-graph (vh ∈ key))    
     ,(add (term key) (set (term vh)))]
    [(add-c-to-graph ({vh ...} ⊆ key)) 
     ,(add (term key) (apply set (term (vh ...))))]
    [(add-c-to-graph (key_1 ⊆ key_2)) 
     ,(E-add! key_1 → (key_1 ⊆ key_2))]
    [(add-c-to-graph (vh_1 ∈ key_1 ⇒ vh_2 ∈ key_2))
     ,(E-add! key_1 → (vh_1 ∈ key_1 ⇒ vh_2 ∈ key_2))]
    [(add-c-to-graph (mf ? key_1 ⇒ vh ∈ key_2))
     ,(E-add! key_1 → (mf ? key_1 ⇒ vh ∈ key_2))]
    [(add-c-to-graph (vh ∈ key_1 ⇒ key_2 ⊆ key_3))
     ,(begin
        (E-add! key_1 → c_⇒)
        (E-add! key_2 → c_⇒))
     (where c_⇒ (vh ∈ key_1 ⇒ key_2 ⊆ key_3))]
    [(add-c-to-graph (∀ mf ∈ key : l ...))
     ,(E-add! key → c_∀)
     (where c_∀ (∀ mf ∈ key : l ... ))]
    [(add-c-to-graph (l ∈ ∆)) ,(add-to-labels-to-delay (term l))]
    [(add-c-to-graph (l ∈ θ)) ,(add-to-labels-to-not-delay (term l))]
    [(add-c-to-graph (l ∈ Γ)) ,(add-to-labels-to-force (term l))]
    [(add-c-to-graph ((l_1 l_2) ∈ Γ)) ,(add-to-labels-to-force (term (l_1 l_2)))])
  
  ;; ***** FINALLY, do the graph building
  (for-each add-c-to-graph-fn constraints)
  
  ;; Step 3) Iterate ----------------------------------------------------------
  (define (process-constraint-fn c) (term (process-constraint ,c)))
  (define-metafunction L
    process-constraint : c -> any ; void
    ;; need some void cases for completeness, so I can use for-each in ∀ case
    ;; void cases are already handled by add-c-to-graph
    [(process-constraint (vh ∈ key)) ,(void)]
    [(process-constraint (key_1 ⊆ key_2))
     ,(add (term key_2) (lookup-in-ρ (term key_1)))]
    [(process-constraint (vh_1 ∈ key_1 ⇒ vh_2 ∈ key_2))
     ,(when (set-member? (lookup-in-ρ (term key_1)) (term vh_1))
        (add (term key_2) (set (term vh_2))))]
    [(process-constraint (mf ? key_1 ⇒ vh ∈ key_2))
     ,(when (for/or ([x (set->list (lookup-in-ρ (term key_1)))])
              ((term mf) x))
        (add (term key_2) (set (term vh))))]
    [(process-constraint (vh ∈ key_1 ⇒ key_2 ⊆ key_2))
     ,(when (set-member? (lookup-in-ρ (term key_1)) (term vh))
        (add (term key_3) (lookup-in-ρ (term key_2))))]
    [(process-constraint (∀ mf ∈ key : l ...)) ; forall constraint
     ,(begin
        ;; add new edges to graph if necessary
        (for-each add-c-to-graph-fn (term (c ...)))
        (for-each process-constraint-fn (term (c ...))))
     (where (c ...) (∀c->cs (∀ mf ∈ key : l ...)))]
    [(process-constraint (l ∈ ∆)) ,(void)]
    [(process-constraint (l ∈ θ)) ,(void)]
    [(process-constraint (l ∈ Γ)) ,(void)]
    [(process-constraint ((l_1 l_2) ∈ Γ)) ,(void)])
  
  ;; ***** FINALLY, traverse the graph and construct the analysis result
  (do ([q (car worklist) ; initial val
          ; subsequent vals
          ; (it's weird because the order goes: 
          ;  1) bind vars 2) check test 3) exe body
          ;  so we have to check for termination condition before binding)
          (unless (null? worklist) (car worklist))])
    ((null? worklist)) ; stop when worklist is null
    (set! worklist (cdr worklist))
    (set-for-each (lookup-in-E q) process-constraint-fn)
    )
  (when (PRINT-ENV)
    (hash-for-each 
     ρ 
     (λ (k v) 
       (printf "~a: " k)
     (set-for-each v (λ (x) (printf "~a " x)))
       (printf "\n"))))
  #;(hash-for-each 
   E
   (λ (k v) 
     (printf "~a: " k)
     (set-for-each v (λ (x) (printf "~a " x)))
     (printf "\n")))
  )



;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------
;; Inserting Delays and Forces
;; ----------------------------------------------------------------------------
;; ----------------------------------------------------------------------------

(define (delay-this-label? l)
  (and (set-member? labels-to-delay l) 
       (not (set-member? labels-to-not-delay l))))
(define (force-this-label? l)
  (or (set-member? labels-to-force l)
      (not (set-empty?
       (set-filter 
        (λ (x) (and (list? x)
                    (= (first x) l) 
;                    (printf "checking forcing of ~a: ~a\n" l x)
                    (delay-this-label? (second x))))
        labels-to-force)))))

; insert-delays : adds lazy annotations according to labels-to-delay
(define-metafunction L
  insert-delays : prog -> prog
  [(insert-delays ((define (f x ...) e_1) ... e))
   ((define (f x ...) (ins-del e_1)) ... (ins-del e))])
(define-metafunction L
  ins-del : e -> e
  [(ins-del (lab l valh)) (lab l valh)]; dont delay literals or values
;  [(ins-del (lab l nh))  (lab l nh)] 
;  [(ins-del (lab l b))    (lab l b)]  
;  [(ins-del (lab l null)) (lab l null)]
  [(ins-del (lab l x))    (lab l x)]   ; dont delay variables
  [(ins-del (lab l (λ (x ...) e))) (lab l (λ (x ...) (ins-del e)))]
  ; dont insert duplicate thunks
  [(ins-del (lab l_1 (lazy (lab l_2 e)))) (lab l_1 (lazy (ins-del (lab l_2 e))))]
  [(ins-del (lab l e)) e_0
   (where e_tmp (ins-del e))
   (where 
    e_0 
    ,(if (delay-this-label? (term l))
         (begin
           ; remove label from labels-to-delay so we don't delay twice
;           (set! labels-to-delay (set-remove labels-to-delay (term l)))
           (add-arrow-var! (hash-ref possible-arrow-vars (term l)))
           (term (label (lazy (lab l e_tmp)))))
         (term (lab l e_tmp))))]
  [(ins-del (cons e_1 e_2))
   (cons (ins-del e_1) (ins-del e_2))]
  ; lcons should be delayed by language
  [(ins-del (lcons e ...)) (lcons (ins-del e) ...)]
  [(ins-del (e ...)) ((ins-del e) ...)]
  [(ins-del (let ([x_1 e_1] ...) e)) (let ([x_1 (ins-del e_1)] ...) (ins-del e))]
  [(ins-del (p e ...)) (p (ins-del e) ...)]
  [(ins-del (zero? e)) (zero? (ins-del e))]
  [(ins-del (null? e)) (null? (ins-del e))]
  [(ins-del (pair? e)) (pair? (ins-del e))]
  [(ins-del (not e)) (not (ins-del e))]
  [(ins-del (if e ...)) (if (ins-del e) ...)]
  [(ins-del (first e)) (first (ins-del e))]
  [(ins-del (rest e)) (rest (ins-del e))]
  [(ins-del (lazy e)) (lazy (ins-del e))]
  [(ins-del (force e)) (force (ins-del e))])

; insert-forces : adds force annotations from labels-to-force
(define-metafunction L
  insert-forces : prog -> prog
  [(insert-forces ((define (f x ...) e_1) ... e))
   ((define (f x ...) (ins-for e_1)) ... (ins-for e))])
(define-metafunction L
  ins-for : e -> e
  [(ins-for (lab l valh)) (lab l valh)] ; dont force literals or values
;  [(ins-for (lab l nh))  (lab l nh)] 
;  [(ins-for (lab l b))    (lab l b)]   ; (should never happen) (?)
;  [(ins-for (lab l null)) (lab l null)]
  [(ins-for (lab l (λ (x ...) e))) (lab l (λ (x ...) (ins-for e)))]
  [(ins-for (lab l (cons  e ...))) (lab l (cons  (ins-for e) ...))]
  [(ins-for (lab l (lcons e ...))) (lab l (lcons (ins-for e) ...))]
  [(ins-for (lab l (force e))) (lab l (force (ins-for e)))] ; dont double force
  [(ins-for (lab l x)) e ; force variables
   (where e ,(if (force-this-label? (term l))
                 (term (label (force (lab l x))))
                 (term (lab l x))))]
  [(ins-for (lab l e)) e_0
   (where e_tmp (ins-for e))
   (where 
    e_0 
    ,(if (force-this-label? (term l))
         (term (label (force (lab l e_tmp))))
         (term (lab l e_tmp))))]
  [(ins-for n) n] [(ins-for b) b] [(ins-for null) null] [(ins-for x) x]
  [(ins-for (e ...)) ((ins-for e) ...)]
  [(ins-for (let ([x_1 e_1] ...) e)) (let ([x_1 (ins-for e_1)] ...) (ins-for e))]
  [(ins-for (p e ...)) (p (ins-for e) ...)]
  [(ins-for (zero? e)) (zero? (ins-for e))]
  [(ins-for (null? e)) (null? (ins-for e))]
  [(ins-for (pair? e)) (pair? (ins-for e))]
  [(ins-for (not e)) (not (ins-for e))]
  [(ins-for (if e ...)) (if (ins-for e) ...)]
  [(ins-for (first e)) (first (ins-for e))]
  [(ins-for (rest e)) (rest (ins-for e))]
  [(ins-for (lazy e)) (lazy (ins-for e))]
  [(ins-for (force e)) (force (ins-for e))])



(caching-enabled? #f)